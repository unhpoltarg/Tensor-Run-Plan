import numpy as np
import scipy as sp
import matplotlib.pyplot as plt
import datetime
from tabulate import tabulate

# This code will estimate the time requirements for running a DNP experiment at JLab

outFile = open('RunPlan.txt','w')


outStr = "Assumptions for Scheduling:     (All times given in HH:MM:SS)\n"


# For the b1 experiment proposal, there were 720 total PAC hours requested 
# Split up for the SHMS:
#       20% @ x=0.15
#       30% @ x=0.3
#       50% @ x=0.495
#
# The HMS had all 100% of its time at x=0.55.

# For the Azz experiment proposal, there were 816 total PAC hours separated by beam energy.
#       3%    @ 2.2 GeV
#       23.5% @ 6.6 GeV
#       73.5% @ 8.8 GeV

# Overhead:
# vvvv Annealing vvvv
#   For annealing, the dose between anneals should be approximately 4e15 to 5e15 e/cm^2. 
#   This is approximately what was used in P.M. McKee, NIM A 526, 60 (2004).
#
#   In order to determine how often anneals occur in time, we need some information.

b_eff = 0.5 # Beam efficiency scaled to 1
I = 85 # nA = beam current
r = 1.5 # cm = target cup radius
#d = 5e15 # e/cm^2 = dose between anneals
d = 4e15 # e/cm^2 = dose between anneals
A = np.pi*r**2 #cm^2 = area of face of target cup
e = d*A/b_eff # e/anneal = # of electrons between anneals
eps = 1.602e-10 # nA = current of 1 e/s
t_s = round(e*eps/I) # s = time per anneal in seconds @ 100% efficiency
t_h = t_s/(60*60) # h = time per anneal in hours @ 100% efficiency
t_btw_anneal = datetime.timedelta(seconds=t_s)
t_anneal = datetime.timedelta(hours=4)

outStr += '   Beam Current: ' + str(I) +' nA\n'
outStr += '   Beam Efficiency: ' + str(b_eff) +' (Scaled to 1)\n'
outStr += '   Target Cup Radius: ' + str(r) + ' cm\n'
outStr += '   Dose between anneals: ' + '{:.2e}'.format(d) + ' e/cm^2\n'
outStr += '   Time Between Anneals: '+ str(t_btw_anneal) + '\n'
outStr += '   Time required for Anneal: '+ str(t_anneal) + '\n'

# print('','Beam Current:',I,'nA')
# print('','Target Cup Radius:',r,'cm')
# print('','Dose between anneals:','{:.2e}'.format(d),'e/cm^2')
# print('','Time Between Anneals:',round(t_h,2),'hours')

t_matChange = datetime.timedelta(hours=(4))
d_matChange = 1e17 # e/cm^2 = dose between material changes
t_btw_matChange = datetime.timedelta(seconds=(round(d_matChange*A*eps/I/b_eff)))
outStr += '   Time required for target material change: ' + str(t_matChange) + '\n'
outStr += '   Dose between target material changes: ' + '{:.2e}'.format(d_matChange) + ' e/cm^2\n'
outStr += '   Time between target material changse: ' + str(t_btw_matChange) + '\n'

# ^^^^ Annealing ^^^^

# vvvv Vector Pol. Cycles vvvv
# From Feb.-Mar. 2023 Hall B ND3 data, the spin-up time constant is approximately 2643 s = 44.05 min = 0.7342 hr. 
# This is an average of three online spin-up fits, giving time constants of 3998.5 s, 2796.5 s, and 1161.2 s.

# Assuming we wait for 4 time constants (98% of max pol.) before running beam, 
# this would come out to about 3 hours of polarizing before starting the next
# vector Pz run cycle. A more conservative estimate might be 3-8 hours between
# cycles, assuming a way of 4 to 10 time constants (98% - 99.995%).
# During the 3 spin-ups in Hall B in Feb/March 2023, they waited 7, 8, and 3 hours.

t_vecSpinUp = datetime.timedelta(hours=6) # Estimates range from 3-8 hours. Taking 6 as average of above.
t_btw_vecSpinUp = datetime.timedelta(days=2)
t_TE = datetime.timedelta(hours=4)
t_pf = datetime.timedelta(hours=1)
outStr += '   Time required for vector pol. spin-ups: ' + str(t_vecSpinUp) + '\n'
outStr += '   Time between each vector pol. spin-up: ' + str(t_btw_vecSpinUp) + '\n'
outStr += '   Time required for target TE measurements:' + str(t_TE) + '\n'
outStr += '   Time required for packing fraction/dilution runs: ' + str(t_pf) + '\n'
# ^^^^ Vector Pol. Cycles ^^^^

# vvvv Beam Overhead vvvv
t_BCM = datetime.timedelta(hours=2)
t_btw_BCM = datetime.timedelta(days=7.5)
t_optics = datetime.timedelta(hours=4)
t_btw_optics = datetime.timedelta(days=20)
t_linacChange = datetime.timedelta(hours=8)
t_specChange = datetime.timedelta(hours=2)
outStr += '   Time required for BCM calibration: ' + str(t_BCM) + '\n'
outStr += '   Beam time between BCM calibrations: ' + str(t_btw_BCM) + '\n'
outStr += '   Time required for each Optics run: ' + str(t_optics) + '\n'
outStr += '   Beam time between Optics runs: ' + str(t_btw_optics) + '\n'
outStr += '   Time required for each Linac change: ' + str(t_linacChange) + '\n'
outStr += '   Time required for each Spectrometer Momentum/angle change: ' + str(t_specChange) + '\n'
# ^^^^ Beam Overhead ^^^^

# vvvv Tensor Pol. Cycle vvvv
# According to Dustin's 2/1/23 email, 
# "It's just a second or so to go from tensor enhanced to vector only (tensor =0).  
# It's also just a second to go from tensor=0 to tensor =! 0.  But optimizing the 
# tensor-enhanced state takes on the order of 20 seconds or so.  Depending on what 
# the overall area of the signal is, the FOM will change greatly even if it's 
# optimized simple because of the values of the polarization which are never great 
# for ND3 after a particular dose has accumulated.
# As an example, if you're at around 25% vector polarized and you want to go from 
# tensor=0 to tensor enhanced, you might be better off not depleting the pedestal 
# because it takes more time to build back up than the peak.  If one were to cycle 
# too fast without giving time for the overall Boltzmann area to build the FOM 
# drops over time. 

t_to_0 = datetime.timedelta(seconds=10)
t_to_Pzz = datetime.timedelta(seconds=30)
dt_between_Pzz_change = datetime.timedelta(minutes=30)

outStr += '   Time to Tensor Enhance: ' + str(t_to_Pzz) + "\n"
outStr += '   Time to Tensor Unpol: ' + str(t_to_0) + "\n"
outStr += '   Time Between Tensor Pol/Unpol Cycles: ' + str(dt_between_Pzz_change) + "\n"
# ^^^^ Tensor Pol. Cycle ^^^^



print('Writing assumptions...')
outFile.write(outStr)

# vvvv Kinematics vvvv

print('Writing kinematics...')
print("\n\nKinematics:",file=outFile)
kineTable = []

AzzAPAC = datetime.timedelta(days=(1))
AzzBPAC = datetime.timedelta(days=(8))
AzzCPAC = datetime.timedelta(days=(25))
b1APAC = datetime.timedelta(days=(6))
b1BPAC = datetime.timedelta(days=(9))
b1CPAC = datetime.timedelta(days=(15))
AzzAReal = datetime.timedelta(days=(2*1))
# AzzAReal = datetime.timedelta(days=(30*1)) # !!!!!!!! THIS IS A TEST! REMOVE LINE WHEN TEST IS COMPLETED!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
AzzBReal = datetime.timedelta(days=(2*8))
AzzCReal = datetime.timedelta(days=(2*25))
b1AReal = datetime.timedelta(days=(2*6))
b1BReal = datetime.timedelta(days=(2*9))
b1CReal = datetime.timedelta(days=(2*15))
#        Sett.   Spec.   E0  Q^2  E'  Theta Spec    E0  Q^2 E'  Theta PAC Time, Real Time
AzzA = ["Azz-A","SHMS", 2.2, 0.2,2.15,10.9,"HMS" , 2.2, 0.3,2.11,14.9,AzzAPAC,AzzAReal]
AzzB = ["Azz-B","SHMS", 6.6, 0.7,6.35, 7.5,"HMS" , 6.6, 1.8,5.96,12.3,AzzBPAC,AzzBReal]
AzzC = ["Azz-C","SHMS", 8.8, 1.5,8.36, 8.2,"HMS" , 8.8, 2.9,7.26,12.2,AzzCPAC,AzzCReal]
b1A  = ["b1-A" ,"SHMS",11.0,1.21,6.70,7.35,"HMS" ,11.0,3.81,7.31,12.5,b1APAC,b1AReal]
b1B  = ["b1-B" ,"SHMS",11.0,2.00,7.45,8.96,"HMS" ,11.0,3.81,7.31,12.5,b1BPAC,b1BReal]
b1C  = ["b1-C" ,"SHMS",11.0,2.58,7.96,9.85,"HMS" ,11.0,3.81,7.31,12.5,b1CPAC,b1CReal]

#                 Setting Spec     E0        Q^2    E'      Theta   PAC Time Real Time
kineTable.append([AzzA[0],AzzA[1], AzzA[2], AzzA[3],AzzA[4],AzzA[5], AzzA[11],AzzA[12]])
kineTable.append([AzzA[0],AzzA[6], AzzA[7], AzzA[8],AzzA[9],AzzA[10],AzzA[11],AzzA[12]])
kineTable.append([AzzB[0],AzzB[1], AzzB[2], AzzB[3],AzzB[4],AzzB[5], AzzB[11],AzzB[12]])
kineTable.append([AzzB[0],AzzB[6], AzzB[7], AzzB[8],AzzB[9],AzzB[10],AzzB[11],AzzB[12]])
kineTable.append([AzzC[0],AzzC[1], AzzC[2], AzzC[3],AzzC[4],AzzC[5], AzzC[11],AzzC[12]])
kineTable.append([AzzC[0],AzzC[6], AzzC[7], AzzC[8],AzzC[9],AzzC[10],AzzC[11],AzzC[12]])

kineTable.append([b1A[0],b1A[1], b1A[2], b1A[3],b1A[4],b1A[5], b1A[11],b1A[12]])
kineTable.append([b1A[0],b1A[6], b1A[7], b1A[8],b1A[9],b1A[10],b1A[11],b1A[12]])
kineTable.append([b1B[0],b1B[1], b1B[2], b1B[3],b1B[4],b1B[5], b1B[11],b1B[12]])
kineTable.append([b1B[0],b1B[6], b1B[7], b1B[8],b1B[9],b1B[10],b1B[11],b1B[12]])
kineTable.append([b1C[0],b1C[1], b1C[2], b1C[3],b1C[4],b1C[5], b1C[11],b1C[12]])
kineTable.append([b1C[0],b1C[6], b1C[7], b1C[8],b1C[9],b1C[10],b1C[11],b1C[12]])

print(tabulate(kineTable, headers=["Setting Name","Spec.","E0 (GeV)", "Q^2 (GeV^2)", "E' (GeV)", "Theta (deg)", "Run Time (PAC)","Run Time (Real)"],tablefmt="grid"),file=outFile)

print('Creating Run Plan...')
print('\n\n\nRun plan:\n',file=outFile)




# define the events and their durations in seconds
events = [
    ("Vector+ Spin-Up", t_vecSpinUp.total_seconds(),
     "Azz-A", AzzAReal.total_seconds()),
    # ("Physics Running", 14400),
    # ("Anneals", 600),
    # ("Tpol", 10),
    # ("Tunpol", 30),
]

# initialize variables
table_data = []
runStartTime = datetime.datetime(2025, 1, 1, 0, 0, 0)
# current_time = runStartTime # This sets the first day to "Day 0"
current_time = runStartTime + datetime.timedelta(hours=24) # This sets the first day to "Day 1"
tpol_count = 0
physics_running_duration = datetime.timedelta(seconds=0)
phys_tot = datetime.timedelta(seconds=0)
overhead_tot = datetime.timedelta(seconds=0)
beam_tot = datetime.timedelta(seconds=0)
setting_tot = datetime.timedelta(seconds=0)

def createEvent(event,duration,spec,concur,beam,overhead,phys):
    global phys_tot
    global beam_tot
    global overhead_tot
    global current_time
    global table_data
    global last_concur
    global concur_dur
    global kine_tot
    global tenPolChg_tot
    global kine_with_pol
    global totAllowedKineTime
    global tenPolChg_tot
    global bcmTimeCheck
    global last_bcm
    global opticsTimeCheck
    global vecSpinFlipTimeCheck
    global annealTimeCheck
    global matChangeTimeCheck
    global TETimeCheck
    global pfTimeCheck
    global isSummary
    isKine = False
    if ("Production" in event) or ("Ten.Pol. to 0" in event) or ("Ten.Pol.Enh." in event) or ("Pzz Changes" in event):
        isKine = True
    # print(event,'isKine =',isKine)
    if isKine and ((kine_with_pol + duration)>totAllowedKineTime):
        duration = totAllowedKineTime - kine_with_pol
    if duration is datetime.timedelta(seconds=0):
        return
    if not isSummary:
        if "TE" in event:
            TETimeCheck = datetime.timedelta(seconds=0)
        elif beam:
            TETimeCheck += duration
        if "Dilution/PF Run" in event:
            pfTimeCheck = datetime.timedelta(seconds=0)
        elif beam:
            pfTimeCheck += duration
        if "Vec.Pol. + Spin-up" in event:
            vecSpinFlipTimeCheck = datetime.timedelta(seconds=0)
        elif beam:
            vecSpinFlipTimeCheck += duration
        if "Vec.Pol. - Spin-up" in event:
            vecSpinFlipTimeCheck = datetime.timedelta(seconds=0)
        elif beam:
            vecSpinFlipTimeCheck += duration
        if "Optics Run" in event:
            opticsTimeCheck = datetime.timedelta(seconds=0)
        else:
            opticsTimeCheck += duration 
        if "Tgt. Anneal" in event:   
            annealTimeCheck = datetime.timedelta(seconds=0)
        else:
            if beam:
                annealTimeCheck += duration
        if "Tgt.Mat. Change" in event:
            matChangeTimeCheck = datetime.timedelta(seconds=0)
        elif beam:
            matChangeTimeCheck += duration
        if "BCM Cal." in event:
            bcmTimeCheck = datetime.timedelta(seconds=0)
        else:
            bcmTimeCheck += duration
    # print('bcmTimeCheck:',bcmTimeCheck,kine_with_pol)
    if "Ten.Pol." in event:
        tenPolChg_tot += duration
    if duration is not datetime.timedelta(seconds=0):
        evtType = ""
        silence = False
        # if ("Ten.Pol." in event) or (duration==dt_between_Pzz_change):
        if isKine:
            kine_with_pol += duration
            if tenPolSilence:
                silence = True
        durTime = str(duration)
        if durTime=="0:00:00":
            return
        if not last_concur:
            if beam:
                beam_tot += duration
                beamStr = "On"
            else:
                beamStr = "Off"
            if overhead:
                overhead_tot += duration
            if phys:
                phys_tot += duration
            if isKine:
                kine_tot += duration
            if concur:
                concur_dur = duration
        else:
            if beam:
                beamStr = "On"
            else:
                beamStr = "Off"
        if last_concur and (not concur):
            current_time += concur_dur
            if overhead:
                overhead_tot += concur_dur
            if phys:
                phys_tot += concur_dur
                kine_tot += concur_dur
        if phys:
            evtType += "Phys."
        if overhead:
            evtType += "O.H."
        if concur:
            evtType += ", Concurrent"
        event_start_time = current_time
        # ["Day", "Start Time", "Duration", "Event", "Type","Setting","Beam","Kine Time","Beam Time","Phys. Time","Overhead Time"]
        if not silence:
            table_data.append([
                (current_time-runStartTime).days,
                event_start_time.strftime("%H:%M:%S"),
                durTime,
                event,
                evtType,
                spec,
                beamStr,
                kine_tot,
                beam_tot,
                phys_tot,
                overhead_tot
            ])
        if concur:
            last_concur = True
        else:
            last_concur = False
            current_time += duration
    if "BCM Cal." in event:
        last_bcm = beam_tot
    # print('Silence =',silence)

def prepSimplifyOutput(kineTime):
    global cntTenEnh
    global cntTen0
    global tenPolChg_tot
    global before_prod_time
    global current_time
    global kine_before_prod
    global kine_tot
    global kine_with_pol
    global kine_with_pol_before
    global totAllowedKineTime 
    global lastPhys
    global before_beam_time
    global beam_tot
    cntTenEnh = 0
    cntTen0 = 0
    tenPolChg_tot = datetime.timedelta(seconds=0)
    before_prod_time = current_time
    kine_before_prod = kine_tot
    # kine_with_pol = datetime.timedelta(seconds=0)
    kine_with_pol_before = kine_with_pol
    totAllowedKineTime = kineTime
    lastPhys = phys_tot
    before_beam_time = beam_tot


def simplifyOutput():
    global phys_tot
    global beam_tot
    global overhead_tot
    global current_time
    global table_data
    global last_concur
    global concur_dur
    global kine_tot
    global tenPolChg_tot
    global kine_with_pol
    global totAllowedKineTime
    global tenPolChg_tot
    global bcmTimeCheck
    global tenPolSilence
    global cntTenEnh
    global cntTen0
    global before_prod_time
    global lastPhys
    global before_beam_time
    global isSummary
    global thisSpec
    prevTenPolSilence = tenPolSilence
    if tenPolSilence:
        tenPolSilence = False
        isSummary = True
        beam_tot = before_beam_time
        kine_with_pol= kine_with_pol_before
        kine_tot = kine_before_prod
        current_time = before_prod_time
        # physTime = AzzAReal - tenPolChg_tot
        physTime = phys_tot - lastPhys
        phys_tot = lastPhys
        # physTime = lastPhys
        # print('phystime:',physTime)
        createEvent("Production",physTime,thisSpec,False,True,False,True)
        PzzChanges = cntTenEnh + cntTen0
        PzzChgStr = "+ " + str(PzzChanges) + " Pzz Changes"
        createEvent(PzzChgStr,tenPolChg_tot,thisSpec,False,True,True,False)
        tenPolSilence = prevTenPolSilence
        cntTenEnh = 0
        cntTen0 = 0
        tenPolChg_tot = datetime.timedelta(seconds=0)
        before_prod_time = current_time
        isSummary = False
        # print(AzzAReal,kine_with_pol)



# Material Change: t_matChange
# Vec.Pol. Spin-Up: t_vecSpinUp
# TE: t_TE
# Packing Fraction/Dilution: t_pf
# BCM Cal.: t_BCM
# Optics: t_optics
# Linac Change: t_linacChange
# Spec. Change: t_specChange
# Ten.Pol. Enh: t_to_Pzz
# Ten.Pol. Zero: t_to_0
# Time Between Ten.Pol. Change: dt_between_Pzz_change
# Time Between BCM Calibrations: t_btw_BCM
# Time Between Optics Runs: t_btw_optics
# Time Between Material Changes: t_btw_matChange
# Time Between anneals: t_btw_anneal
# Time Between Vec.Pol. Change: t_btw_vecSpinUp

last_concur = False
isSummary = False

tenPolSilence = True
# tenPolSilence = False

# Full Run
allKineTime = [AzzA[12],AzzB[12],AzzC[12],b1A[12],b1B[12],b1C[12]]
specSetting = [AzzA[0],AzzB[0],AzzC[0],b1A[0],b1B[0],b1C[0]]

# Azz Only
# allKineTime = [AzzA[12],AzzB[12],AzzC[12]]
# specSetting = [AzzA[0],AzzB[0],AzzC[0]]

# b1 Only
# allKineTime = [b1A[12],b1B[12],b1C[12]]
# specSetting = [b1A[0],b1B[0],b1C[0]]

for i in range(0,len(specSetting)):
    
    thisSpec = specSetting[i]
    print("Writing plan for",thisSpec)
    thisKineTime = allKineTime[i]
    if (thisSpec is b1B[0]) or (thisSpec is b1C[0]):
        needLinacChange = False
    else:
        needLinacChange = True
    if (thisSpec is AzzA[0]):
        t_btw_vecSpinUp = datetime.timedelta(hours=12)
    else:
        t_btw_vecSpinUp = datetime.timedelta(days=2)

    kine_tot = datetime.timedelta(seconds=0)
    kine_with_pol = datetime.timedelta(seconds=0)
    bcmTimeCheck = datetime.timedelta(seconds=0)
    opticsTimeCheck = datetime.timedelta(seconds=0)
    vecSpinFlipTimeCheck = datetime.timedelta(seconds=0)
    annealTimeCheck = datetime.timedelta(seconds=0)
    matChangeTimeCheck = datetime.timedelta(seconds=0)
    TETimeCheck = datetime.timedelta(seconds=0)
    pfTimeCheck = datetime.timedelta(seconds=0)
    
    # createEvent(event,duration,spec,concur,beam,overhead,phys)
    if needLinacChange:
        createEvent("LINAC Change",t_linacChange,thisSpec,True,False,True,False)
    createEvent("Spectro. Change",t_specChange,thisSpec,True,False,True,False)
    vecPolDir = "+"
    createEvent("Vec.Pol. "+vecPolDir+" Spin-up",t_vecSpinUp,thisSpec,False,False,True,False)
    createEvent("BCM Cal.",t_BCM,thisSpec,False,True,True,False)
    createEvent("Optics Run",t_optics,thisSpec,False,True,True,False)
    createEvent("Dilution/PF Run",t_pf,thisSpec,False,True,True,False)
    createEvent("TE",t_TE,thisSpec,True,False,True,False)
    
    prepSimplifyOutput(thisKineTime)
    while kine_with_pol < thisKineTime:
        # if kine_with_pol >= t_btw_vecSpinUp:
        createEvent("Ten.Pol.Enh.",t_to_Pzz,thisSpec,False,True,True,False)
        cntTenEnh += 1
        # tenPolChg_tot += t_to_Pzz
        createEvent("Production",dt_between_Pzz_change,thisSpec,False,True,False,True)
        createEvent("Ten.Pol. to 0",t_to_0,thisSpec,False,True,True,False)
        cntTen0 += 1
        # tenPolChg_tot += t_to_0
        createEvent("Production",dt_between_Pzz_change,thisSpec,False,True,False,True)
        # print(AzzAReal,kine_with_pol)
        if bcmTimeCheck > t_btw_BCM:
            simplifyOutput()
            createEvent("BCM Cal.",t_BCM,thisSpec,False,True,True,False)
            prepSimplifyOutput(thisKineTime)
        if opticsTimeCheck > t_btw_optics:
            simplifyOutput()
            createEvent("Optics Run",t_optics,thisSpec,False,True,True,False)
            prepSimplifyOutput(thisKineTime)
        if vecSpinFlipTimeCheck > t_btw_vecSpinUp:       
            simplifyOutput()
            prepSimplifyOutput(thisKineTime)
            if vecPolDir == "+":
                vecPolDir = "-"
            else:
                vecPolDir = "+"
            createEvent("Vec.Pol. "+vecPolDir+" Spin-up",t_vecSpinUp,thisSpec,False,False,True,False)
        if annealTimeCheck > t_btw_anneal:
            simplifyOutput()
            prepSimplifyOutput(thisKineTime)
            createEvent("Tgt. Anneal",t_anneal,thisSpec,False,False,True,False)
        if matChangeTimeCheck > t_btw_matChange:
            simplifyOutput()
            prepSimplifyOutput(thisKineTime)
            createEvent("Tgt.Mat. Change",t_matChange,thisSpec,False,False,True,False)
    simplifyOutput()
    createEvent("BCM Cal.",t_BCM,thisSpec,False,True,True,False)
    createEvent("Optics Run",t_optics,thisSpec,False,True,True,False)
    createEvent("Dilution/PF Run",t_pf,thisSpec,False,True,True,False)
    createEvent("TE",t_TE,thisSpec,True,False,True,False)

    
    
    
    # global TETimeCheck
    # global pfTimeCheck
    
    
    
    
    


    










# # loop over each event
# for event, duration in events:
#     # initialize variables for this event
#     event_start_time = current_time
#     cumulative_time = datetime.timedelta(seconds=0)




#     # add rows to the table for Tpol and Tunpol sub-events during Physics Running
#     if event == "Physics Running":
#         for i in range(duration):
#             if i % 600 == 0:
#                 tpol_count += 1
#                 tpol_start_time = current_time
#                 table_data.append([
#                     " ",
#                     tpol_start_time.strftime("%H:%M:%S"),
#                     "00:00:10",
#                     "Tpol",
#                     "",
#                 ])
#                 current_time += datetime.timedelta(seconds=10)
#                 physics_running_duration += datetime.timedelta(seconds=10)
#                 if physics_running_duration >= datetime.timedelta(hours=4):
#                     break
#                 table_data.append([
#                     " ",
#                     current_time.strftime("%H:%M:%S"),
#                     "00:00:30",
#                     "Tunpol",
#                     "",
#                 ])
#                 current_time += datetime.timedelta(seconds=20)
#                 physics_running_duration += datetime.timedelta(seconds=20)
#                 if physics_running_duration >= datetime.timedelta(hours=4):
#                     break
#             else:
#                 current_time += datetime.timedelta(seconds=1)
#                 physics_running_duration += datetime.timedelta(seconds=1)
#                 if physics_running_duration >= datetime.timedelta(hours=4):
#                     break

#     # for non-Physics Running events, just add one row to the table
#     else:
#         current_time += datetime.timedelta(seconds=duration)
#         cumulative_time += datetime.timedelta(seconds=duration)
#         if event == "Physics Running":
#             cumulative_time += physics_running_duration
#             physics_running_duration = datetime.timedelta(seconds=0)
#         table_data.append([
#             (current_time - cumulative_time).strftime("%d"),
#             event_start_time.strftime("%H:%M:%S"),
#             str(datetime.timedelta(seconds=duration)),
#             event,
#             str(cumulative_time),
#         ])

# print the table
print('Writing Run Plan...')
# print(tabulate(table_data, headers=["Day", "Start Time", "Duration", "Event", "Cumulative Time"],tablefmt="grid"))
print(tabulate(table_data, headers=["Day", "Start Time", "Duration", "Event","Type", "Kine.","Beam","Kine. Time","Beam Time","Phys. Time","Overhead Time"],tablefmt="grid"),file=outFile)
# print(tabulate(table_data, headers=["Day", "Start Time", "Duration", "Event","Type", "Kine.","Beam","Kine. Time","Beam Time","Phys. Time","Overhead Time"]),file=outFile)


physTimeStr = "Total Physics Time: " + str(phys_tot)
ohTimeStr = "Total Overhead Time: " + str(overhead_tot)
totTimeStr = "Grand Total Time: " + str(phys_tot+overhead_tot)

beamTimeStr = "\nTotal Beam Time: " + str(beam_tot) + "\n"

print('\n\n\nSummary:',file=outFile)
print('For these experiments, we were allotted',file=outFile)
print('Azz = 34 PAC Days + 11 OH Days   = 68 + 11   Real Days = 79   Real Days',file=outFile)
print('b1  = 30 PAC Days + 10.8 OH Days = 60 + 10.8 Real Days = 70.8 Real Days',file=outFile)
print('Physics Total = Azz + b1 = 128 days Real Time',file=outFile)
print('Overhead Total = Azz + b1 = 21 days, 19:12:00 Real Time',file=outFile)
print('Grand Total = Azz + b1 = 149 days, 19:12:00 Real Time',file=outFile)
print('\n\nBased on this run plan, we expect to spend',file=outFile)
print(physTimeStr,file=outFile)
print(ohTimeStr,file=outFile)
print(totTimeStr,file=outFile)
# print(beamTimeStr,file=outFile)



outFile.close()
print('All done!')